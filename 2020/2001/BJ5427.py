# 불! 불! 불이야!
# 딕-셔너-리로 한 번 풀어보겠읍니다!

# 불 BFS 돌려서 각 time 별 (x,y)의 정보를 저장해둔다
# fire_mat = [[]]

# fire_mat에 상근 BFS를 돌려본다.
# 만약 depth + 1 보다 해당 좌표 fire의 값이 더 크면 통과,
# 만약 depth + 1 보다 해당 좌표 fire의 값이 더 작으면 fail
from pprint import pprint as pp

import collections
testcase = int(input())
def isPath(x, y):
    if 0 <= x < h and 0 <= y < w:
        if mat[x][y] == '@' or mat[x][y] == '.':
            return True
        else:
            return False
    else:
        return False

def fire_BFS(depth, x, y):
    global fire_mat
    queue = collections.deque()
    queue.append((depth, x, y))
    while queue:
        depth, x, y = queue.popleft()
        if not fire_mat[x][y] or fire_mat[x][y] > depth:
            fire_mat[x][y] = depth
            for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
                nx = x + dx
                ny = y + dy
                if isPath(nx, ny) and (not fire_mat[nx][ny] or fire_mat[nx][ny] > depth+1):
                    queue.append((depth+1, nx, ny))
    
def sang_BFS(depth,x,y):
    queue = collections.deque()
    queue.append((depth, x, y))
    while queue:
        depth, x, y = queue.popleft()
        if not visit[x][y]:
            visit[x][y] = depth
            if x == 0 or x == h-1 or y == 0 or y == w-1:
                return depth
            for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
                nx = x + dx
                ny = y + dy
                if isPath(nx,ny) and (not fire_mat[nx][ny] or fire_mat[nx][ny] > depth+1):
                    queue.append((depth+1, nx,ny))
    return 'IMPOSSIBLE'

for t in range(testcase):
    w, h = map(int, input().split())
    mat = [input() for _ in range(h)]
    fire_mat = [[0]*w for _ in range(h)]
    visit = [[0]*w for _ in range(h)]
    flag = 0
    for x in range(h):
        for y in range(w):
            if ((y == 0 or y == w-1) or (x == 0 or x == h-1)) and (mat[x][y] != '#' or mat[x][y]!= '*'):
                flag = 1
            if mat[x][y] == '*':
                fire_BFS(1,x,y)
            elif mat[x][y] == '@':
                start = (x,y)
    if not flag:
        print('IMPOSSIBLE')
    else:
        print(sang_BFS(1,start[0],start[1]))

    # pp(fire_mat)
    # pp(visit)



"""
21
1 1
@
3 3
.#.
#@#
.#.
3 3
...
.@.
...
3 3
.#.
#@#
.#*
8 3
########
#*@.....
########
5 6
##.##
#...#
#.#.#
#.#@#
#*#.#
#####
5 6
##.##
#...#
#.#.#
#*#@#
#.#.#
#####
5 6
##.##
#...#
#*#.#
#.#@#
#.#.#
#####
8 9
########
#......#
#.####.#
#.#@.#.#
#.##.#.#
#....#.#
######.#
#......#
########
5 3
##.##
#*.@#
#####
7 7
.......
.*#.##.
.##.##.
...@...
.##.##.
.##.#*.
.......
7 7
......*
.##.##.
.##.##.
...@...
.##.##.
.##.##.
*......
7 7
.*....*
.##.##.
.##.##.
...@...
.##.##.
.##.##.
.*....*
7 7
.......
*##.##*
.##.##.
...@...
.##.##.
.##.##.
*.....*
7 7
*....*.
.##.##.
.##.##.
...@...
.##.##.
.##.##.
*....*.
7 7
*.....*
.##.##.
.##.##.
...@...
.##.##.
*##.##*
.......
7 7
..#.#..
.*#.#*.
.##.##.
...@...
.##.##.
.*#.#*.
.......
7 7
.......
.*#.#*.
.##.###
...@...
.##.###
.*#.#*.
.......
7 7
.......
.*#.#*.
###.##.
...@...
###.##.
.*#.#*.
.......
7 7
.......
.*#.#*.
.##.##.
...@...
.##.##.
.*#.#*.
..#.#..
5 3
..#..
.@#*.
..#..

"""

# def isPath(x, y):
#     if 0 <= x < h and 0 <= y < w:
#         if mat[x][y] == '@' or mat[x][y] == '.':
#             return True
#         else:
#             return False
#     else:
#         return False


# def escape():
#     global turn
#     while True:
#         flag = 0
#         temp = {}
#         temp2 = {}

#         for sx, sy in SG.keys():
#             if sx == 0 or sx == h-1 or sy == 0 or sy == w-1:
#                 return turn

#         for x, y in fire.keys():
#             if fire.get((x, y)) == turn:
#                 for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
#                     nx = x + dx
#                     ny = y + dy
#                     if isPath(nx, ny):
#                         if not fire.get((nx, ny)):
#                             temp[(nx, ny)] = turn + 1

#         fire.update(temp)
#         for x, y in SG.keys():
#             if SG.get((x, y)) == turn:
#                 for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
#                     nx = x + dx
#                     ny = y + dy
#                     if isPath(nx, ny):
#                         if not fire.get((nx, ny)):
#                             temp2[(nx, ny)] = turn + 1
#                             flag = 1

#         SG.update(temp2)
#         for sx, sy in SG.keys():
#             if sx == 0 or sx == h-1 or sy == 0 or sy == w-1:
#                 return SG.get((sx, sy))
#         turn += 1
#         if not flag:
#             return 'IMPOSSIBLE'


# for t in range(testcase):
#     w, h = map(int, input().split())
#     mat = [input() for _ in range(h)]
#     fire_mat = [[0]*w for _ in range(h)]

#     # {depth(turn) : [(좌표)]}
#     SG = dict()

#     # {depth(turn): [좌표]}
#     fire = dict()

#     turn = 1
#     for x in range(h):
#         for y in range(w):
#             if mat[x][y] == '*':
#                 fire[(x, y)] = turn
#             elif mat[x][y] == '@':
#                 SG[(x, y)] = turn
#     print(escape())


# 지도 1 회 순회
    # 상근이 위치 저장
    # 불 위치 저장
    # 벽 위치 저장
# def escape():
    # turn = 0
    # while !탈출:
    # fire = 불의 현재 위치 + 다음 턴 불의 위치
    # SG = 현재 위치에서 사방 확인, depth += 1, 갈 수 있는 곳이면 저장
    # turn += 1

    # 만약 상근이가 탈출성공하면 return turn
    # 더이상 갈 곳이 없다면, (SG에 이번 턴에 추가된 것이 없다면) return IMPOSSIBLE

"""
1
5 5
..#.#
....#
#*#..
#.@.#
###..
1
3 3
*.*
.@.
*.*
1
50 50
##################################################
#@...............................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
##########################################.#######

"""
