from pprint import pprint as pp
# 불! 불! 불이야!
testcase = int(input())
# 딕-셔너-리로 한 번 풀어보겠읍니다!

# 불 BFS 돌려서 각 time 별 (x,y)의 정보를 저장해둔다
# fire_mat = [[]]

# fire_mat에 상근 BFS를 돌려본다.
# 만약 depth + 1 보다 해당 좌표 fire의 값이 더 크면 통과,
# 만약 depth + 1 보다 해당 좌표 fire의 값이 더 작으면 fail
def isPath(x, y):
    if 0 <= x < h and 0 <= y < w:
        if mat[x][y] == '@' or mat[x][y] == '.':
            return True
        else:
            return False
    else:
        return False

def fire_BFS(depth, x, y):
    global fire_mat
    queue = []
    queue.append((depth, x, y))
    while queue:
        depth, x, y = queue.pop(0)
        if not fire_mat[x][y] or fire_mat[x][y] > depth:
            fire_mat[x][y] = depth
            for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
                nx = x + dx
                ny = y + dy
                if isPath(nx, ny) and (not fire_mat[nx][ny] or fire_mat[nx][ny] > depth+1):
                    queue.append((depth+1, nx, ny))
    
def sang_BFS(depth,x,y):
    queue = []
    queue.append((depth, x, y))
    while queue:
        depth, x, y = queue.pop(0)
        if not visit[x][y] :
            visit[x][y] = depth
            for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
                nx = x + dx
                ny = y + dy
                if isPath(nx,ny) and (not fire_mat[nx][ny] or fire_mat[nx][ny] < depth+1):
                    queue.append((depth+1, nx,ny))


for t in range(testcase):
    w, h = map(int, input().split())
    mat = [input() for _ in range(h)]
    fire_mat = [[0]*w for _ in range(h)]
    visit = [[0]*w for _ in range(h)]
    
    for x in range(h):
        for y in range(w):
            if mat[x][y] == '*':
                fire_BFS(0,x,y)
            elif mat[x][y] == '@':
                start = (x,y)
    
    sang_BFS(0,start[0],start[1])
    pp(fire_mat)
    pp(visit)
    


"""
1
7 6
###.###
#*#.#*#
#.....#
#.....#
#..@..#
#######
"""

# def isPath(x, y):
#     if 0 <= x < h and 0 <= y < w:
#         if mat[x][y] == '@' or mat[x][y] == '.':
#             return True
#         else:
#             return False
#     else:
#         return False


# def escape():
#     global turn
#     while True:
#         flag = 0
#         temp = {}
#         temp2 = {}

#         for sx, sy in SG.keys():
#             if sx == 0 or sx == h-1 or sy == 0 or sy == w-1:
#                 return turn

#         for x, y in fire.keys():
#             if fire.get((x, y)) == turn:
#                 for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
#                     nx = x + dx
#                     ny = y + dy
#                     if isPath(nx, ny):
#                         if not fire.get((nx, ny)):
#                             temp[(nx, ny)] = turn + 1

#         fire.update(temp)
#         for x, y in SG.keys():
#             if SG.get((x, y)) == turn:
#                 for dx, dy in (0, 1), (0, -1), (-1, 0), (1, 0):
#                     nx = x + dx
#                     ny = y + dy
#                     if isPath(nx, ny):
#                         if not fire.get((nx, ny)):
#                             temp2[(nx, ny)] = turn + 1
#                             flag = 1

#         SG.update(temp2)
#         for sx, sy in SG.keys():
#             if sx == 0 or sx == h-1 or sy == 0 or sy == w-1:
#                 return SG.get((sx, sy))
#         turn += 1
#         if not flag:
#             return 'IMPOSSIBLE'


# for t in range(testcase):
#     w, h = map(int, input().split())
#     mat = [input() for _ in range(h)]
#     fire_mat = [[0]*w for _ in range(h)]

#     # {depth(turn) : [(좌표)]}
#     SG = dict()

#     # {depth(turn): [좌표]}
#     fire = dict()

#     turn = 1
#     for x in range(h):
#         for y in range(w):
#             if mat[x][y] == '*':
#                 fire[(x, y)] = turn
#             elif mat[x][y] == '@':
#                 SG[(x, y)] = turn
#     print(escape())


# 지도 1 회 순회
    # 상근이 위치 저장
    # 불 위치 저장
    # 벽 위치 저장
# def escape():
    # turn = 0
    # while !탈출:
    # fire = 불의 현재 위치 + 다음 턴 불의 위치
    # SG = 현재 위치에서 사방 확인, depth += 1, 갈 수 있는 곳이면 저장
    # turn += 1

    # 만약 상근이가 탈출성공하면 return turn
    # 더이상 갈 곳이 없다면, (SG에 이번 턴에 추가된 것이 없다면) return IMPOSSIBLE

"""
1
5 5
..#.#
....#
#*#..
#.@.#
###..
1
3 3
*.*
.@.
*.*
1
50 50
##################################################
#@...............................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
#................................................#
##########################################.#######

"""
